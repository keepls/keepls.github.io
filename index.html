<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>jc</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="jc">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="jc">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="jc" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">jc</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-面试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/22/%E9%9D%A2%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2022-04-22T03:59:38.364Z" itemprop="datePublished">2022-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/22/%E9%9D%A2%E8%AF%95/">面试题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.vueAPP适配是怎么写的，用的什么单位？</span><br><span class="line">2.get和post有什么区别？</span><br><span class="line">3.计算属性和监听器有什么区别？</span><br><span class="line">4.v-for渲染列表是key是用来做什么的？</span><br><span class="line">5.数据请求在生命周期哪一个阶段？</span><br><span class="line">6.水平居中有哪几种方法？</span><br><span class="line">7.flex弹性盒模型？</span><br><span class="line">8.父盒子中子盒子浮动有什么后果？</span><br><span class="line">9.清除浮动有哪些方法？</span><br><span class="line">10.定位有哪些属性？相对定位是相对什么定位？</span><br><span class="line">11.行没元素和行内块元素有什么区别？行内块元素在同一行显示时有默认空隙，如何解决？</span><br><span class="line">12.给DOM元素绑定事件有哪些方法？</span><br><span class="line">13.数组里面有哪些遍历方法？es6</span><br></pre></td></tr></table></figure>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.js中的闭包指什么？ </span><br><span class="line">2.v-if和v-show的区别是什么？分别的使用场景。</span><br><span class="line">3.v-for中 key值的作用？</span><br><span class="line">4.vue中插槽的作用？</span><br><span class="line">5.js的执行机制</span><br></pre></td></tr></table></figure>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1,原生js继承怎么实现</span><br><span class="line">2,es6里面有什么类和方法</span><br><span class="line">3,vue相关的问题</span><br><span class="line">4,jquery和vue的区别</span><br><span class="line">5,vue中父子组件和兄弟组件怎么传的</span><br><span class="line">6,vuex和axios和使用</span><br><span class="line">7,es6里const <span class="built_in">let</span> var 区别</span><br><span class="line">8,js里的垃圾回收机制</span><br><span class="line">9,使用js怎么调bug</span><br></pre></td></tr></table></figure>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1.html5增加了mainheaderfooterasidesectionvideoaudiotimedata之类的语义化标签, 搜索引擎会利用爬虫分析抓取页面结构内容，有利于SEO，页面结构更加清晰，利于维护.提高页面可访问性，不会在样式加载不正常的时候一团乱，维持基本结构。利于部分残障人士页面阅读器解析</span><br><span class="line"></span><br><span class="line">2.浮动脱离了正常文档流,会导致父元素高度塌陷，后面元素会挤到浮动元素下方，造成布局错乱。清除浮动:1.父元素创建BFC，使其处于单独的块级渲染区域 overflow不为visible,<span class="built_in">float</span>不为none,display值为flex grid inline-box table, position为absolute或fixed都可以创建。2.父元素的伪元素::after display:block,heght:0,visbility:hidden,clear:both,content:.</span><br><span class="line"></span><br><span class="line">3.行元素无法设置宽高,行排布,不够换行 a b span img input button label, 块元素独占一行,可以设置宽高 p div ul ol form table , 还有空元素:link br hr等 </span><br><span class="line"></span><br><span class="line">4.cookie sessionStorage localStorage indexDb,cookie按设定的时间内有效，最多4k, 两个storage都是html5新api,存储键值对,sessionStorage会话存储,页面访问时间内有效，关闭页面失效,localStorage一直有效，关闭页面不会失效，两个都是最大5M，indexdb也是h5新api，浏览器内置小型数据库。</span><br><span class="line"></span><br><span class="line">5.考变量提升和作用域,i先增加到了10,setTimeout为宏任务,10ms后宏任务里陆续增加了10个<span class="function"><span class="title">function</span></span>()&#123;<span class="built_in">log</span>(i)&#125;回调,10次事件循环每次把一个宏任务取到栈里,执行打印i, 10次10</span><br><span class="line">6.Vue双向绑定 vm视图模型简单来说就是利用了Object.defineProperty(),通过劫持setter,实现model到view，view到model则是一堆事件监听 输入框的input,选择组件的 change等等。具体复杂些的实现就要看观察订阅设计模式了</span><br><span class="line"></span><br><span class="line">7.父-子:props, 子-父:  子:emit,父 on,兄弟之间: 利用一个事件中央总线bus</span><br><span class="line"></span><br><span class="line">8.可能是: 全局一个promise实例,不同按钮点击:在实例<span class="keyword">then</span>后返回新的不同promise连接到全局promise,应该可以保证顺序吧。。</span><br><span class="line"></span><br><span class="line">９.text-overflow:ellipsis??</span><br><span class="line">9.  white-space:nowrap; overflow:hidden;text-overflow:ellipsis;</span><br><span class="line"></span><br><span class="line">10.简单说:几个钩子函数created,mounted,updated,destroyed 再加上四个before，created时data绑定，el不可见。beforemount调用render,实例添加<span class="variable">$el</span>替换el后调用mounted,数据更新触发视图渲染则调用两个update,销毁实例之前调用beforedestroy。</span><br><span class="line"></span><br><span class="line">11.跨域浏览器安全策略造成，非同协议，源，端口　皆为跨域，为了避免csrf跨域请求伪造，请求会被浏览器拦截。</span><br><span class="line">实现跨域请求:jsonp ,后端设置CORS, 各种代理 像nginx,node中间件。跨域访问dom:Window.postMessage, document.domain,iframe</span><br><span class="line">jsonp原理:利用script不受同源政策限制,将请求模拟成script标签请求,写入callback回调函数，后台将结果用callback包装返回，回调函数即可得到数据，，不过jsonp只支持get请求</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">h5新增的标签有哪些，为什么要加强语义化？</span><br><span class="line">为什么要清除浮动，怎么清除浮动？</span><br><span class="line">行内元素，块元素有哪些？它们有什么不同？</span><br><span class="line">现在有哪几种存储数据的方式，它们分别有什么不同？</span><br><span class="line">程序题<span class="keyword">for</span>（i=0;i10;i++)&#123;setTimeout(<span class="function"><span class="title">function</span></span>()&#123;console.log(i)&#125;,10)&#125;</span><br><span class="line">vue实现双向绑定的原理是什么</span><br><span class="line">Vue之间组件是怎么传值的</span><br><span class="line">让两个组件实现按点击次序执行请求</span><br><span class="line">怎么实现文本不自动换行，超出文本的部分变成省略号</span><br><span class="line">vue的生命周期有哪些，分别有什么不同</span><br><span class="line">跨域的原理有哪些，jsonp的原理是什么？</span><br></pre></td></tr></table></figure>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1,讲一下es6有哪些新特性</span><br><span class="line">2,css3中的anvas绘画，node.js webpack是否有了解</span><br><span class="line">3,html第一行！doctype是做上面用的</span><br><span class="line">4,css动画特性可以用js实现，网上还要用css实现</span><br><span class="line">5,ajax请求数据重新处理和拦截器</span><br><span class="line">6,boorstarp中栏珊的24个是怎么做到的</span><br><span class="line">7,轮播图怎么考虑实现的</span><br><span class="line">8,git的常用操作</span><br><span class="line">9,除了视频网站学习还会怎么学习</span><br><span class="line">10,简单说下get和post的区别</span><br><span class="line">11,h5的新特性，和css3的新特性</span><br><span class="line">12,seo的搜索引擎优化</span><br><span class="line">13,const定义对象能否改变</span><br><span class="line">14,<span class="built_in">let</span>和var在全局定义的时候有上面区别</span><br><span class="line">15,js的三大事件</span><br></pre></td></tr></table></figure>
<h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">,闭包是什么，有什么优点和缺点</span><br><span class="line">2,怎么让子盒子上下居中</span><br><span class="line">3,js的本地的储存有哪些</span><br><span class="line">4,cookie和session了解吗</span><br><span class="line">5,跨域怎么做</span><br><span class="line">6,this的指向问题</span><br><span class="line">7,vue项目中用什么UI框架</span><br><span class="line">8,npm中warn了解吗</span><br><span class="line">9,node.js了解吗</span><br><span class="line">10,详细说下做的项目</span><br><span class="line">11,</span><br></pre></td></tr></table></figure>
<h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、学过哪些基础框架</span><br><span class="line">2、vue的源码看过吗？怎么实现数据劫持</span><br><span class="line">3、vue双向数据绑定</span><br><span class="line">4、vue的生命周期</span><br><span class="line">5、分别在什么时候使用created，mounted</span><br><span class="line">6、用过es6，es7吗？列举常用的。</span><br><span class="line">7、promise  async  await用过吗</span><br><span class="line">8、箭头函数和一般函数有什么区别</span><br><span class="line">9、有没有了解过后端的语言</span><br><span class="line">10、jQuery中绑定事件用的on和<span class="built_in">bind</span>有什么区别</span><br><span class="line">11、前端常用的性能优化有哪些方法</span><br><span class="line">12 闭包是什么？举例说明</span><br><span class="line">13 vue中的组件data为什么是函数</span><br></pre></td></tr></table></figure>
<h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">7/13（海康）</span><br><span class="line">闭包是什么？有什么优点和缺点？</span><br><span class="line">怎么让盒子上下居中？//定位和弹性盒子</span><br><span class="line">Js的本地储存方式有哪些？（自己补充下大概怎么用）</span><br><span class="line">cookie中的session了解吗？</span><br><span class="line">跨域怎么实现？//1.jsonp 2.代理 3.php header写允许跨域</span><br><span class="line">This的指向问题（过谁调用<span class="keyword">function</span>(),就指向谁。而Vue中一般指向的是this所在的组件Vue实例本身）</span><br><span class="line">怎么改变this的指向？//1.箭头函数 2.that 3.apply,call,<span class="built_in">bind</span> 4.new</span><br><span class="line">vue项目中用了什么UI框架？//up主用的是animate.css,个人推荐饿了么</span><br><span class="line">Npm 中的warn了解吗？（面试官估计被实习生坑过）</span><br><span class="line">Node.js了解吗？</span><br><span class="line">详细描述一个自己的项目。（码字君：主要是面向信息处理类的，别搞那么花里胡哨。简历随便别处偷几张好看的图应付HR，github里面放段文字跟技术面试官说明就好）</span><br><span class="line">“up主题外话，关于华为素质面试的，大厂关注的是抗压力(不想压力大的请转行)，学习能力（潜力），还有一些特长（相信大家都不是天才，给Hr画饼就好了）”</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7/19</span><br><span class="line">H5标签有哪些？</span><br><span class="line">Css中的定位？//浮动，定位，弹性盒子</span><br><span class="line">es6有哪些新特性，<span class="built_in">let</span> var const的区别。</span><br><span class="line">什么是闭包？</span><br><span class="line">Vue的生命周期？（可以自己跟面试官补充常见的钩子函数的操作，增加good Image）</span><br><span class="line">Vue中this从哪里可以开始调用？</span><br><span class="line">Js的基本数据类型，别忘了es6新增的symbol</span><br><span class="line">怎么判断数据类型，typeOf引用类型，instanceOf引用类型</span><br><span class="line">（算法，高概率多准备）给数组去重//只回答了一个</span><br><span class="line"> </span><br><span class="line">7/18</span><br><span class="line">学过哪些基础框架？</span><br><span class="line">（糊弄下）有没看过Vue的源码？怎么实现数据劫持？</span><br><span class="line">“绑定和传值的原理”</span><br><span class="line">Vue的生命周期？什么情况使用created,mounted</span><br><span class="line">Es6特性(自己补充下ES6的一些常识和基础操作)</span><br><span class="line">Promise async await用过吗</span><br><span class="line">箭头函数和一般函数有什么区别？（自己补充下箭头函数的一些常识）</span><br><span class="line">有没了解过后端语言（大概讲讲对node和php的涉猎）</span><br><span class="line">Jquery中绑定事件用的on和<span class="built_in">bind</span>有什么区别？//面试官，on绑定父级会冒泡，<span class="built_in">bind</span>绑定自己不会冒泡</span><br><span class="line">前端常用的性能优化有哪些？</span><br><span class="line">打开页面，速度比较慢，该怎么做</span><br><span class="line">闭包是什么？举例说明</span><br><span class="line">（每次介绍面试官都会让你问他问题，砸一些准备好的高技术难题给他，让他对你印象深刻嘻嘻）</span><br><span class="line">[other：</span><br><span class="line">vue中的组件的data为什么是函数</span><br><span class="line">Vue-cli是如何使用json数据模拟</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7/12</span><br><span class="line">Es6有哪些新特性</span><br><span class="line">Css3中的canvas绘图，node.js,webpack是否了解过？（没时间的学最好百度下涉猎个大概，这问题最好回答下一点点）</span><br><span class="line">html第一行!doctype是作什么用的？（上面的那个问题，up主一点都没回答，根据头几个问题，面试官已经把她分类到菜鸡小萌新的级别，接下来面试官要做的只是看她符不符合最低要求，和有什么亮点）</span><br><span class="line">css动画特性可以用js实现，为什么还要用css实现？</span><br><span class="line">Ajax请求数据重新处理和拦截器</span><br><span class="line">boorstrap中栏删的24个是怎么做到的？</span><br><span class="line">轮播图怎么考虑实现？（原生js怎么作的和UI插件。“争取在自己熟知的知识点跟面试官讲多几句，长时间的良性谈话会让面试官产生感觉你挺ok的错误心理。另外吹水能力也超级重要，是吹水不是吹牛”）</span><br><span class="line">Git的常用操作。（自己补充一些关于git的项目好习惯）</span><br><span class="line">除了视频网站还会怎么学习？（主要回答博客和简书，然后大概说诸如电子笔记和请教大佬的学习习惯。最好让整个面试谈话让人感觉饱满，不然三言两语的干巴巴几分钟鬼记得你）</span><br><span class="line">简单说一下get和post的区别</span><br><span class="line">H5的新特性？Css3的新特性？</span><br><span class="line">SEO搜索引擎优化？</span><br><span class="line">const定义对象能否改变？//能！因为定义的对象还是存储在堆当中，const只是存了地址</span><br><span class="line">Let和var在全局定义的时候有什么区别？</span><br><span class="line">Js的三大事件//捕获，冒泡这些事件</span><br><span class="line"> </span><br><span class="line">7/10  （华为电话面试）（大厂问题比较吊，去小厂的混子不推荐研究）</span><br><span class="line">原生js里继承是怎么实现的？用prototype是怎么实现的</span><br><span class="line">es6里面新增了类和方法</span><br><span class="line">Class和继承。是怎么实现继承的</span><br><span class="line">jquery和Vue使用起来有什么区别？（jquery和Vue主要是开发思想不同。具体的区别最好自己百度）</span><br><span class="line">Vue里面父子组件怎么传值？//用订阅者模式bus</span><br><span class="line">设计模式了解吗？（模式这些大中厂一般都会问，小厂一般不问）</span><br><span class="line">vue中Vuex和Axios的使用</span><br><span class="line">Es6里面const <span class="built_in">let</span> var 的区别？</span><br><span class="line">闭包是什么？用<span class="built_in">let</span>怎么实现</span><br><span class="line">Js的垃圾回收机制？</span><br><span class="line">在使用js的时候怎么调bug</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6/16  (网易电话面试)</span><br><span class="line">闭包是什么？（破厂都喜欢问这问题）</span><br><span class="line">Js的执行机制是什么？</span><br><span class="line">Vue   v-for中key的作用？</span><br><span class="line">V-if和v-show的区别？</span><br><span class="line">Vue中插槽有什么作用？</span><br><span class="line">（up主不是211就是985，不然不会那么多次大厂会有电话）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">8/3（第三次海康，恭喜Up喜提offer！！！）</span><br><span class="line">电话面试</span><br><span class="line">Js的基本数据类型</span><br><span class="line">Js中怎么绑定事件</span><br><span class="line">深拷贝和浅拷贝的区别，怎么实现深拷贝</span><br><span class="line">数组的常用操作方法？Splice和slice的区别</span><br><span class="line">Es6里面的 <span class="built_in">let</span> var const</span><br><span class="line">事件委托是什么</span><br><span class="line">简要说明get和post的区别</span><br><span class="line">简要说明v-if和v-show的区别</span><br><span class="line">父子组件，兄弟组件之间的传值</span><br><span class="line"> </span><br><span class="line">现场面试</span><br><span class="line">http请求头content-type？//根据请求头的<span class="built_in">type</span>类型解码</span><br><span class="line">Es6里面Promise的两个参数分别是什么？//第一个参数表示成功时的回调函数，第二个是失败状态的回调函数</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">in</span>和<span class="keyword">for</span> of的区别？//不会就讲讲自己对它的了解</span><br><span class="line">Vue的computed和watch区别，以及应用场景</span><br><span class="line">Vue生命周期，用过哪些，怎么用的，mounted里面一般放什么?</span><br><span class="line">V-if和v-show区别，项目中的使用</span><br><span class="line">v-for在项目中的使用，key值的作用，对使用效率的影响，没有key会出现什么情况？</span><br><span class="line">《面试官了解你的面试项目情况》项目中的每一个功能详解，要手写代码（后台数据模拟，获取数据），项目难点//项目难点准备用以提问面试官</span><br><span class="line">父子组件传值，兄弟组件传值，Vuex代码怎么写</span><br><span class="line">bootstrap,jquery分别用了哪些，css选择器的优先级，子代/后代</span><br><span class="line">学校竞赛，学习途径，《js高级程序设计》中函数重载，vue使用版本</span><br></pre></td></tr></table></figure>
<h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">8/4(宇视)</span><br><span class="line">先笔试在电话面试</span><br><span class="line"> </span><br><span class="line">笔试：选择题(20道)和填空题，还有算法题(3-5道)</span><br><span class="line"> </span><br><span class="line">在js的浏览器对象模型当中，windows对象当中什么属性是用来指定用来指定浏览器状态栏里面的临时消息的?//这个是status</span><br><span class="line">两个div采用绝对定位，设置层叠关系，需要设置什么：z-index</span><br><span class="line">《<span class="built_in">eval</span>函数，它可不可以解释由JS原码组成的字符串呢？//可以的，</span><br><span class="line">然后这个函数能不能用调式工具的断点来调试呢?//是不可以用断点，</span><br><span class="line">这个函数是js自带的函数，使用的话会不会引起安全问题呢？//是会的，它会引起XSS攻击，</span><br><span class="line">还有一个就是这个函数，它会不会有效率问题，该函数是动态解释字符串，会不会存在效率问题？//当时写的是会，效率问题主要还是在自身逻辑上面（建议自行百度）</span><br><span class="line">》</span><br><span class="line">html网页元素加载完后触发哪个事件？//选项有onready  onchange  onload  onblur ？Onready是先于onload执行的，onload是要等所有元素包括img之类的加载完成之后才会执行的，而onready是只要DOM结构绘制完成就能执行。如果有多个onload函数，它只会执行最后一个函数，而onready是有多少个执行多少个。</span><br><span class="line"> </span><br><span class="line">addEventListener可不可以多次给DOM对象添加监听事件？//是可以的。（简述：一个监听对象一般只会有一个监听事件，多余的会移除掉）</span><br><span class="line"> </span><br><span class="line">attachEvent可以删除DOM对象的监听事件吗？//是不可以的，这是用来监听的，如果要删除的话，用removeEvent。</span><br><span class="line"> </span><br><span class="line">New Date（）可以获取的是哪里的时间？是PC本地的时间</span><br><span class="line"> </span><br><span class="line">Form标签之间可以出现p、u等非表单域元素吗？//是可以的，form可以包含包括input,文本，单选，复选，textarea等</span><br><span class="line"> </span><br><span class="line">在JS里，两个整数进行除法，得到的数是整数还是小数？//是小数,要得到整数则用parseInt和Math.round等等。</span><br><span class="line"> </span><br><span class="line">属性document.body.scrollWidth,表示的是网页中滚动条的宽度吗？不是的，它表示的是网页正文全文的宽度。</span><br></pre></td></tr></table></figure>
<h3 id="11"><a href="#11" class="headerlink" title="11"></a>11</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">8/5(宇视，电话面试)</span><br><span class="line">Vue生命周期</span><br><span class="line">v-if和v-show的区别</span><br><span class="line">Vuex大概怎么使用，在什么场景应用？</span><br><span class="line">单页面应用的优缺点？</span><br><span class="line">轮播图是怎么实现的？</span><br><span class="line">后台数据抓取怎么写？</span><br><span class="line">跨域的方法有哪些，常用的是怎么用？</span><br><span class="line">安全性问题，在无法使用https情况下，在局域网里面如何防止报文攻击？</span><br><span class="line"> </span><br><span class="line">//以下站友分享，怎么理解前端，怎么学习前端，对后端语言了解程度</span><br><span class="line">常用浏览器及其内核</span><br><span class="line">http和https分别是什么，有什么区别？</span><br><span class="line">cookie和session分别有什么作用</span><br><span class="line">前端性能优化有哪些方法</span><br><span class="line">从输入url到加载完成中间发生了什么？//不同理解程度的人理解有很多，up主推荐大家查一查</span><br><span class="line">可以通过什么途径查到一个网站现在使用了什么技术//开发者工具里查看。Source</span><br><span class="line">react的核心是什么？</span><br><span class="line">Vue router的钩子函数有哪些，哪一个是全局使用的钩子</span><br></pre></td></tr></table></figure>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-2"><a href="#2-2" class="headerlink" title="2"></a>2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-3"><a href="#2-3" class="headerlink" title="2"></a>2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-4"><a href="#2-4" class="headerlink" title="2"></a>2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/22/%E9%9D%A2%E8%AF%95/" data-id="cl29z23wh0002igvj3vtyb9g0" data-title="面试题" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-http" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/22/http/" class="article-date">
  <time class="dt-published" datetime="2022-04-22T03:59:38.363Z" itemprop="datePublished">2022-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/22/http/">HTTP五大类面试题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;http是什么？描述一下&quot;</span></span><br><span class="line">http是超文本传输协议，也就是HyperText Transfer Protocol</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;能否详细解释超文本传输协议？&quot;</span></span><br><span class="line">1 协议</span><br><span class="line"></span><br><span class="line">在生活中，我们也能随处可见协议，例如</span><br><span class="line">刚毕业时会签一个三方协议</span><br><span class="line">找房子时会签一个租房协议。</span><br><span class="line"></span><br><span class="line">生活中的协议，本质上与计算机中的协议是相同的</span><br><span class="line">「协」字，代表的意思是必须有两个以上的参与者。例如三方协议里的参与者有三个：你、公司、学校三个；租房协议里的参与者有两个：你和房东。</span><br><span class="line">「仪」字，代表的意思是对参与者的一种行为约定和规范。例如三方协议里规定试用期期限、毁约金等；租房协议里规定租期期限、每月租金金额、违约如何处理等。</span><br><span class="line"></span><br><span class="line">针对 HTTP 协议，我们可以这么理解</span><br><span class="line">HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）。</span><br><span class="line"></span><br><span class="line">2. 「传输」</span><br><span class="line">所谓的「传输」，很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点 搬到 A 点。</span><br><span class="line">别轻视了这个简单的动作，它至少包含两项重要的信息。</span><br><span class="line">HTTP 协议是一个双向协议。</span><br><span class="line">我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。</span><br><span class="line">数据虽然是在 A 和 B 之间传输，但允许中间有中转或接力。</span><br><span class="line">就好像第一排的同学想穿递纸条给最后一排的同学，那么传递的过程中就需要经过好多个同学（中间人），这样的传输方式就从「A &lt; --- &gt; B」，变成了「A &lt;-&gt; N &lt;-&gt; M &lt;-&gt; B」。</span><br><span class="line">而在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。</span><br><span class="line">针对传输，我们可以进一步理解了 HTTP。</span><br><span class="line">HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 「超文本」</span><br><span class="line">HTTP 传输的内容是「超文本」。</span><br><span class="line">我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」。的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算做「文本」。</span><br><span class="line">再来理解「超文本」，它就是超越了普通文本的文本，它是文字、图片、视频等的混合体最关键有超链接，能从一个超文本跳转到另外一个超文本。</span><br><span class="line">HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，在经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。</span><br><span class="line">OK，经过了对 HTTP 里这三个名词的详细解释，就可以给出比「超文本传输协议」这七个字更准确更有技术含量的答案：</span><br><span class="line">HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;那「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」 ，这种说法正确吗？&quot;</span></span><br><span class="line">这种说法是不正确的。因为也可以是「服务器&lt; -- &gt;服务器」，所以采用两点之间的描述会更准确。</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;HTTP 常见的状态码，有哪些？&quot;</span></span><br><span class="line">1xx</span><br><span class="line">    1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。</span><br><span class="line"></span><br><span class="line">2xx</span><br><span class="line">    2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。</span><br><span class="line">    「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。</span><br><span class="line">    「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</span><br><span class="line">    「206 Partial Content」是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</span><br><span class="line"></span><br><span class="line">3xx</span><br><span class="line">    3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。</span><br><span class="line">    「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</span><br><span class="line">    「302 Moved Permanently」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</span><br><span class="line">    301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</span><br><span class="line">    「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。</span><br><span class="line"></span><br><span class="line">4xx</span><br><span class="line">    4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。</span><br><span class="line">    「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。</span><br><span class="line">    「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。</span><br><span class="line">    「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</span><br><span class="line"></span><br><span class="line">5xx</span><br><span class="line">    5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。</span><br><span class="line">    「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</span><br><span class="line">    「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</span><br><span class="line">    「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</span><br><span class="line">    「503 Service Unavailable」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;http 常见字段有哪些？&quot;</span></span><br><span class="line">Host</span><br><span class="line">    客户端发送请求时，用来指定服务器的域名。</span><br><span class="line">    Host: http://www.A.com</span><br><span class="line">    有了 Host 字段，就可以将请求发往「同一台」服务器上的不同网站。</span><br><span class="line"></span><br><span class="line">Content-Length 字段</span><br><span class="line">    服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。</span><br><span class="line">    Content-Length: 1000</span><br><span class="line">    如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。</span><br><span class="line"></span><br><span class="line">Connection 字段</span><br><span class="line">    Connection 字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。</span><br><span class="line">    HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 Keep-Alive。</span><br><span class="line">    Connection: keep-alive</span><br><span class="line">    一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。</span><br><span class="line"></span><br><span class="line">Content-Type 字段</span><br><span class="line">    Content-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</span><br><span class="line">    Content-Type: text/html; charset=utf-8</span><br><span class="line">    上面的类型表明，发送的是网页，而且编码是UTF-8。</span><br><span class="line">    客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式。</span><br><span class="line">    Accept: */*</span><br><span class="line">    上面代码中，客户端声明自己可以接受任何格式的数据。</span><br><span class="line"></span><br><span class="line">Content-Encoding 字段</span><br><span class="line">    Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</span><br><span class="line">    Content-Encoding: gzip</span><br><span class="line">    上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。</span><br><span class="line">    客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法。</span><br><span class="line">    Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure>
<h3 id="GET与POST"><a href="#GET与POST" class="headerlink" title="GET与POST"></a>GET与POST</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;说一下 GET 和 POST 的区别？&quot;</span></span><br><span class="line">Get 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。</span><br><span class="line">比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。</span><br><span class="line">而POST 方法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报文的 body 里。</span><br><span class="line">比如，你在我文章底部，敲入了留言后点击「提交」（暗示你们留言），浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;GET 和 POST 方法都是安全和幂等的吗？&quot;</span></span><br><span class="line">先说明下安全和幂等的概念：</span><br><span class="line">    在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</span><br><span class="line">    所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</span><br><span class="line"></span><br><span class="line">那么很明显 GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</span><br><span class="line">POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;你知道的 HTTP（1.1） 的优点有哪些，怎么体现的？&quot;</span></span><br><span class="line">HTTP 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。</span><br><span class="line">1. 简单</span><br><span class="line">    HTTP 基本的报文格式就是 header + body，头部信息也是 key-value 简单文本的形式，易于理解，降低了学习和使用的门槛。</span><br><span class="line"></span><br><span class="line">2. 灵活和易于扩展</span><br><span class="line">    HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。</span><br><span class="line">    同时 HTTP 由于是工作在应用层（ OSI 第七层），则它下层可以随意变化。</span><br><span class="line">    HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCPP 层换成了基于 UDP 的 QUIC。</span><br><span class="line"></span><br><span class="line">3. 应用广泛和跨平台</span><br><span class="line">    互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用片地开花，同时天然具有跨平台的优越性。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;那它的缺点呢？&quot;</span></span><br><span class="line">HTTP 协议里有优缺点一体的双刃剑，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。</span><br><span class="line"></span><br><span class="line">1. 无状态双刃剑</span><br><span class="line">    无状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。</span><br><span class="line">    无状态的坏处，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。</span><br><span class="line">    例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。</span><br><span class="line">    这样每操作一次，都要验证信息，这样的购物体验还能愉快吗？别问，问就是酸爽！</span><br><span class="line">    对于无状态的问题，解法方案有很多种，其中比较简单的方式用 Cookie 技术。</span><br><span class="line">    Cookie 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</span><br><span class="line">    相当于，在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了了，</span><br><span class="line"></span><br><span class="line">2. 明文传输双刃剑</span><br><span class="line">    明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。</span><br><span class="line">    但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于信息裸奔。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那你号没了。</span><br><span class="line"></span><br><span class="line">3. 不安全</span><br><span class="line">    HTTP 比较严重的缺点就是不安全：</span><br><span class="line">        通信使用明文（不加密），内容可能会被窃听。比如，账号信息容易泄漏，那你号没了。</span><br><span class="line">        不验证通信方的身份，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多，那你钱没了。</span><br><span class="line">        无法证明报文的完整性，所以有可能已遭篡改。比如，网页上植入垃圾广告，视觉污染，眼没了。</span><br><span class="line"></span><br><span class="line">    HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;那你说下 HTTP/1.1 的性能如何？&quot;</span></span><br><span class="line">HTTP 协议是基于 TCP/IP，并且使用了「请求 - 应答」的通信模式，所以性能的关键就在这两点里。</span><br><span class="line">1. 长连接</span><br><span class="line">    早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。</span><br><span class="line">    为了解决上述 TCP 连接问题，HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</span><br><span class="line">    持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</span><br><span class="line"></span><br><span class="line">2. 管道网络传输</span><br><span class="line">    HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</span><br><span class="line">    即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</span><br><span class="line">    举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。</span><br><span class="line">    但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是 前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」。</span><br><span class="line"></span><br><span class="line">3. 队头阻塞</span><br><span class="line">    「请求 - 应答」的模式加剧了 HTTP 的性能问题。</span><br><span class="line">    因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「队头阻塞」。好比上班的路上塞车。</span><br><span class="line">    总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。</span><br></pre></td></tr></table></figure>
<h3 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;HTTP 与 HTTPS 有哪些区别？&quot;</span></span><br><span class="line">HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</span><br><span class="line">HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</span><br><span class="line">HTTP 的端口号是 80，HTTPS 的端口号是 443。</span><br><span class="line">HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;HTTPS 解决了 HTTP 的哪些问题？&quot;</span></span><br><span class="line">HTTP 由于是明文传输，所以安全上存在以下三个风险：</span><br><span class="line">    窃听风险，比如通信链路上可以获取通信内容，用户号容易没。</span><br><span class="line">    篡改风险，比如强制入垃圾广告，视觉污染，用户眼容易瞎。</span><br><span class="line">    冒充风险，比如冒充淘宝网站，用户钱容易没。</span><br><span class="line"></span><br><span class="line">HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议。</span><br><span class="line">HTTP 与 HTTPS可以很好的解决了上述的风险：</span><br><span class="line">    信息加密：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</span><br><span class="line">    校验机制：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</span><br><span class="line">    身份证书：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</span><br><span class="line"></span><br><span class="line">可见，只要自身不做「恶」，SSL/TLS 协议是能保证通信是安全的。</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;HTTPS 是如何解决上面的三个风险的？&quot;</span></span><br><span class="line">混合加密的方式实现信息的机密性，解决了窃听的风险。</span><br><span class="line">摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</span><br><span class="line">将服务器公钥放入到数字证书中，解决了冒充的风险。</span><br><span class="line">1. 混合加密</span><br><span class="line">    通过混合加密的方式可以保证信息的机密性，解决了窃听的风险。</span><br><span class="line">    HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：</span><br><span class="line">        在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。</span><br><span class="line">        在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。</span><br><span class="line"></span><br><span class="line">    采用「混合加密」的方式的原因：</span><br><span class="line">        对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</span><br><span class="line">        非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 摘要算法</span><br><span class="line">    摘要算法用来实现完整性，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。</span><br><span class="line">    客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」一同</span><br><span class="line">    加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的「指纹」和当前算出的「指纹」做比较，若「指纹」相同，说明数据是完整的。</span><br><span class="line"></span><br><span class="line">3. 数字证书</span><br><span class="line">    客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</span><br><span class="line">    这就存在些问题，如何保证公钥不被篡改和信任度？</span><br><span class="line">    所以这里就需要借助第三方权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</span><br><span class="line">    通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;HTTPS 是如何建立连接的？其间交互了什么？&quot;</span></span><br><span class="line">SSL/TLS 协议基本流程：</span><br><span class="line">    客户端向服务器索要并验证服务器的公钥。</span><br><span class="line">    双方协商生产「会话秘钥」。</span><br><span class="line">    双方采用「会话秘钥」进行加密通信。</span><br><span class="line"></span><br><span class="line">前两步也就是 SSL/TLS 的建立过程，也就是握手阶段。</span><br><span class="line">SSL/TLS 的「握手阶段」涉及四次通信，可见下图：</span><br><span class="line">SSL/TLS 协议建立的详细流程：</span><br><span class="line">    1. ClientHello</span><br><span class="line">        首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。</span><br><span class="line">        在这一步，客户端主要向服务器发送以下信息：</span><br><span class="line">            （1）客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。</span><br><span class="line">            （2）客户端生产的随机数（Client Random），后面用于生产「会话秘钥」。</span><br><span class="line">            （3）客户端支持的密码套件列表，如 RSA 加密算法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    2. SeverHello</span><br><span class="line">        服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：</span><br><span class="line">            （1）确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。</span><br><span class="line">            （2）服务器生产的随机数（Server Random），后面用于生产「会话秘钥」。</span><br><span class="line">            （3）确认的密码套件列表，如 RSA 加密算法。</span><br><span class="line">            （4）服务器的数字证书。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    3.客户端回应</span><br><span class="line">        客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</span><br><span class="line">        如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：</span><br><span class="line">            （1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。</span><br><span class="line">            （2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</span><br><span class="line">            （3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</span><br><span class="line"></span><br><span class="line">        上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。</span><br><span class="line"></span><br><span class="line">    4. 服务器的最后回应</span><br><span class="line">        服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息：</span><br><span class="line">            （1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</span><br><span class="line">            （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</span><br><span class="line"></span><br><span class="line">        至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="HTTP-1-1-HTTP-2-HTTP-3-演变"><a href="#HTTP-1-1-HTTP-2-HTTP-3-演变" class="headerlink" title="HTTP/1.1 HTTP/2 HTTP/3 演变"></a>HTTP/1.1 HTTP/2 HTTP/3 演变</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;说说 HTTP/1.1 相比 HTTP/1.0 提高了什么性能？&quot;</span></span><br><span class="line">HTTP/1.1 相比 HTTP/1.0 性能上的改进：</span><br><span class="line">    使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。</span><br><span class="line">    支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</span><br><span class="line"></span><br><span class="line">但 HTTP/1.1 还是有性能瓶颈：</span><br><span class="line">    请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；</span><br><span class="line">    发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</span><br><span class="line">    服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</span><br><span class="line">    没有请求优先级控制；</span><br><span class="line">    请求只能从客户端开始，服务器只能被动响应。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;那上面的 HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？&quot;</span></span><br><span class="line">HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。</span><br><span class="line">那 HTTP/2 相比 HTTP/1.1 性能上的改进：</span><br><span class="line">    1. 头部压缩</span><br><span class="line">        HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的分。</span><br><span class="line">        这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</span><br><span class="line"></span><br><span class="line">    2. 二进制格式</span><br><span class="line">        HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式。</span><br><span class="line">        头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧。</span><br><span class="line">        这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率。</span><br><span class="line"></span><br><span class="line">    3. 数据流</span><br><span class="line">        HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</span><br><span class="line">        每个请求或回应的所有数据包，称为一个数据流（Stream）。</span><br><span class="line">        每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</span><br><span class="line">        客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。</span><br><span class="line"></span><br><span class="line">    4. 多路复用</span><br><span class="line">        HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。</span><br><span class="line">        移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。</span><br><span class="line">        举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</span><br><span class="line"></span><br><span class="line">    5. 服务器推送</span><br><span class="line">        HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。</span><br><span class="line">        举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？&quot;</span></span><br><span class="line">HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。</span><br><span class="line">所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。</span><br><span class="line">    HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了</span><br><span class="line">    HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。</span><br><span class="line"></span><br><span class="line">这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！</span><br><span class="line">UDP 发生是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的一个丢包全部重传问题。</span><br><span class="line">大家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。</span><br><span class="line">    QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。</span><br><span class="line">    TL3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack。</span><br><span class="line">    HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。</span><br><span class="line"></span><br><span class="line">所以， QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复用的协议。</span><br><span class="line">QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以 HTTP/3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/22/http/" data-id="cl29z23wc0001igvj91lr6jxy" data-title="HTTP五大类面试题" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-css/css" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/22/css/css/" class="article-date">
  <time class="dt-published" datetime="2022-04-22T03:59:38.362Z" itemprop="datePublished">2022-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/22/css/css/">css 相关</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="什么是认证（Authentication）"><a href="#什么是认证（Authentication）" class="headerlink" title="什么是认证（Authentication）"></a>什么是认证（Authentication）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通俗地讲就是验证当前用户的身份，证明“你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功）</span><br><span class="line">互联网中的认证：</span><br><span class="line">    用户名密码登录</span><br><span class="line">    邮箱发送登录链接</span><br><span class="line">    手机号接收验证码</span><br><span class="line">    只要你能收到邮箱/验证码，就默认你是账号的主人</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="什么是授权（Authorization）"><a href="#什么是授权（Authorization）" class="headerlink" title="什么是授权（Authorization）"></a>什么是授权（Authorization）</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/22/css/css/" data-id="cl29z23wk0003igvj2g92adp0" data-title="css 相关" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Cookie、Session、Token、JWT" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/22/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT/" class="article-date">
  <time class="dt-published" datetime="2022-04-22T03:59:38.361Z" itemprop="datePublished">2022-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/22/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT/">Cookie、Session、Token、JWT</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="什么是认证（Authentication）"><a href="#什么是认证（Authentication）" class="headerlink" title="什么是认证（Authentication）"></a>什么是认证（Authentication）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通俗地讲就是验证当前用户的身份，证明“你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功）</span><br><span class="line">互联网中的认证：</span><br><span class="line">    用户名密码登录</span><br><span class="line">    邮箱发送登录链接</span><br><span class="line">    手机号接收验证码</span><br><span class="line">    只要你能收到邮箱/验证码，就默认你是账号的主人</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="什么是授权（Authorization）"><a href="#什么是授权（Authorization）" class="headerlink" title="什么是授权（Authorization）"></a>什么是授权（Authorization）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用户授予第三方应用访问该用户某些资源的权限</span><br><span class="line">    你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限）</span><br><span class="line">    你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）</span><br><span class="line"></span><br><span class="line">实现授权的方式有：cookie、session、token、OAuth</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="什么是凭证（Credentials）"><a href="#什么是凭证（Credentials）" class="headerlink" title="什么是凭证（Credentials）"></a>什么是凭证（Credentials）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">实现认证和授权的前提</span><br><span class="line">是需要一种媒介（证书）来标记访问者的身份</span><br><span class="line">在战国时期，商鞅变法，发明了照身帖。照身帖由官府发放，是一块打磨光滑细密的竹板，上面刻有持有人的头像和籍贯信息。国人必须持有，如若没有就被认为是黑户，或者间谍之类的。</span><br><span class="line">在现实生活中，每个人都会有一张专属的居民身份证，是用于证明持有人身份的一种法定证件。通过身份证，我们可以办理手机卡/银行卡/个人贷款/交通出行等等，这就是认证的凭证。</span><br><span class="line">在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="什么是-Cookie"><a href="#什么是-Cookie" class="headerlink" title="什么是 Cookie"></a>什么是 Cookie</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</span><br><span class="line">cookie 存储在客户端： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</span><br><span class="line">cookie 是不可跨域的： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。</span><br><span class="line">cookie 重要的属性</span><br><span class="line">    属性说明name=value键值对，设置 Cookie 的名称及相对应的值，都必须是字符串类型- 如果值为 Unicode 字符，需要为字符编码。- 如果值为二进制数据，则需要使用 BASE64 编码。domain指定 cookie 所属域名，默认是当前域名path指定 cookie 在哪个路径（路由）下生效，默认是 <span class="string">&#x27;/&#x27;</span>。如果设置为/abc，则只有/abc下的路由可以访问到该 cookie，如：/abc/<span class="built_in">read</span>。maxAgecookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。-比 expires 好用。expires过期时间，在设置的某个时间点后该 cookie 就会失效。一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除secure该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为<span class="literal">false</span>。当 secure 值为 <span class="literal">true</span> 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。httpOnly如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="什么是-Session"><a href="#什么是-Session" class="headerlink" title="什么是 Session"></a>什么是 Session</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">session 是另一种记录服务器和客户端会话状态的机制</span><br><span class="line">session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中</span><br><span class="line">session 认证流程：</span><br><span class="line">    用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session</span><br><span class="line">    请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器</span><br><span class="line">    浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</span><br><span class="line">    当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</span><br><span class="line"></span><br><span class="line">根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">安全性： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。</span><br><span class="line">存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。</span><br><span class="line">有效期不同： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。</span><br><span class="line">存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="什么是-Token（令牌）"><a href="#什么是-Token（令牌）" class="headerlink" title="什么是 Token（令牌）"></a>什么是 Token（令牌）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Acesss Token&quot;</span></span><br><span class="line">    访问资源接口（API）时所需要的资源凭证</span><br><span class="line">    简单 token 的组成： uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</span><br><span class="line">    特点：</span><br><span class="line">        服务端无状态化、可扩展性好</span><br><span class="line">        支持移动端设备</span><br><span class="line">        安全</span><br><span class="line">        支持跨程序调用</span><br><span class="line"></span><br><span class="line">    token 的身份验证流程：</span><br><span class="line">        客户端使用用户名跟密码请求登录</span><br><span class="line">        服务端收到请求，去验证用户名与密码</span><br><span class="line">        验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端</span><br><span class="line">        客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里</span><br><span class="line">        客户端每次向服务端请求资源的时候需要带着服务端签发的 token</span><br><span class="line">        服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据</span><br><span class="line"></span><br><span class="line">    每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里</span><br><span class="line">    基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库</span><br><span class="line">    token 完全由应用管理，所以它可以避开同源策略</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Refresh Token&quot;</span></span><br><span class="line">    另外一种 token——refresh token</span><br><span class="line">    refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。</span><br><span class="line">    Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。</span><br><span class="line">    Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Token-和-Session-的区别"><a href="#Token-和-Session-的区别" class="headerlink" title="Token 和 Session 的区别"></a>Token 和 Session 的区别</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而 Token 是令牌，访问资源接口（API）时所需要的资源凭证。Token 使服务端无状态化，不会存储会话信息。</span><br><span class="line">Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。</span><br><span class="line">所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="什么是-JWT"><a href="#什么是-JWT" class="headerlink" title="什么是 JWT"></a>什么是 JWT</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。</span><br><span class="line">是一种认证授权机制。</span><br><span class="line">JWT 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。</span><br><span class="line">可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。</span><br><span class="line">阮一峰老师的 JSON Web Token 入门教程 讲的非常通俗易懂，这里就不再班门弄斧了</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="JWT-的原理"><a href="#JWT-的原理" class="headerlink" title="JWT 的原理"></a>JWT 的原理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JWT 认证流程：</span><br><span class="line">    用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT</span><br><span class="line">    客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）</span><br><span class="line">    当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是下面这样</span><br><span class="line"></span><br><span class="line">服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为</span><br><span class="line">因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要</span><br><span class="line">因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</span><br><span class="line">因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="JWT-的使用方式"><a href="#JWT-的使用方式" class="headerlink" title="JWT 的使用方式"></a>JWT 的使用方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</span><br><span class="line">方式一</span><br><span class="line">    当用户希望访问一个受保护的路由或者资源的时候，可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT。</span><br><span class="line">    GET /calendar/v1/events</span><br><span class="line">    Host: http://api.example.com</span><br><span class="line">    Authorization: Bearer &lt;token&gt;</span><br><span class="line">    用户的状态不会存储在服务端的内存中，这是一种 无状态的认证机制</span><br><span class="line">    服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为。</span><br><span class="line">    由于 JWT 是自包含的，因此减少了需要查询数据库的需要</span><br><span class="line">    JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务。</span><br><span class="line">    因为 JWT 并不使用 Cookie ，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</span><br><span class="line"></span><br><span class="line">方式二</span><br><span class="line">    跨域的时候，可以把 JWT 放在 POST 请求的数据体里。</span><br><span class="line"></span><br><span class="line">方式三</span><br><span class="line">    通过 URL 传输</span><br><span class="line">    http://www.example.com/user?token=xxx</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Token-和-JWT-的区别"><a href="#Token-和-JWT-的区别" class="headerlink" title="Token 和 JWT 的区别"></a>Token 和 JWT 的区别</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">相同：</span><br><span class="line">    都是访问资源的令牌</span><br><span class="line">    都可以记录用户的信息</span><br><span class="line">    都是使服务端无状态化</span><br><span class="line">    都是只有验证成功后，客户端才能访问服务端上受保护的资源</span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line">    Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。</span><br><span class="line">    JWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="常见的前后端鉴权方式"><a href="#常见的前后端鉴权方式" class="headerlink" title="常见的前后端鉴权方式"></a>常见的前后端鉴权方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Session-Cookie</span><br><span class="line">Token 验证（包括 JWT，SSO）</span><br><span class="line">OAuth2.0（开放授权）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="常见的加密算法"><a href="#常见的加密算法" class="headerlink" title="常见的加密算法"></a>常见的加密算法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">哈希算法(Hash Algorithm)又称散列算法、散列函数、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。哈希算法将数据重新打乱混合，重新创建一个哈希值。</span><br><span class="line">哈希算法主要用来保障数据真实性(即完整性)，即发信人将原始消息和哈希值一起发送，收信人通过相同的哈希函数来校验原始数据是否真实。</span><br><span class="line">哈希算法通常有以下几个特点：</span><br><span class="line">    2 的 128 次方为 340282366920938463463374607431768211456，也就是 10 的 39 次方级别</span><br><span class="line">    2 的 160 次方为 1.4615016373309029182036848327163e+48，也就是 10 的 48 次方级别</span><br><span class="line">    2 的 256 次方为 1.1579208923731619542357098500869 × 10 的 77 次方，也就是 10 的 77 次方</span><br><span class="line">    正像快速：原始数据可以快速计算出哈希值</span><br><span class="line">    逆向困难：通过哈希值基本不可能推导出原始数据</span><br><span class="line">    输入敏感：原始数据只要有一点变动，得到的哈希值差别很大</span><br><span class="line">    冲突避免：很难找到不同的原始数据得到相同的哈希值，宇宙中原子数大约在 10 的 60 次方到 80 次方之间，所以 2 的 256 次方有足够的空间容纳所有的可能，算法好的情况下冲突碰撞的概率很低：</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">    以上不能保证数据被恶意篡改，原始数据和哈希值都可能被恶意篡改，要保证不被篡改，可以使用RSA 公钥私钥方案，再配合哈希值。</span><br><span class="line">    哈希算法主要用来防止计算机传输过程中的错误，早期计算机通过前 7 位数据第 8 位奇偶校验码来保障（12.5% 的浪费效率低），对于一段数据或文件，通过哈希算法生成 128bit 或者 256bit 的哈希值，如果校验有问题就要求重传。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;使用 cookie 时需要考虑的问题&quot;</span></span><br><span class="line">因为存储在客户端，容易被客户端篡改，使用前需要验证合法性</span><br><span class="line">不要存储敏感数据，比如用户密码，账户余额</span><br><span class="line">使用 httpOnly 在一定程度上提高安全性</span><br><span class="line">尽量减少 cookie 的体积，能存储的数据量不能超过 4kb</span><br><span class="line">设置正确的 domain 和 path，减少数据传输</span><br><span class="line">cookie 无法跨域</span><br><span class="line">一个浏览器针对一个网站最多存 20 个Cookie，浏览器一般只允许存放 300 个Cookie</span><br><span class="line">移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;使用 session 时需要考虑的问题&quot;</span></span><br><span class="line">将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session</span><br><span class="line">当网站采用集群部署的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。</span><br><span class="line">当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。</span><br><span class="line">sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？ 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现</span><br><span class="line">移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;使用 token 时需要考虑的问题&quot;</span></span><br><span class="line">如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。</span><br><span class="line">token 完全由应用管理，所以它可以避开同源策略</span><br><span class="line">token 可以避免 CSRF 攻击(因为不需要 cookie 了)</span><br><span class="line">移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;使用 JWT 时需要考虑的问题&quot;</span></span><br><span class="line">因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</span><br><span class="line">JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</span><br><span class="line">JWT 不加密的情况下，不能将秘密数据写入 JWT。</span><br><span class="line">JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</span><br><span class="line">JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。</span><br><span class="line">JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</span><br><span class="line">JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。</span><br><span class="line">为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;使用加密算法时需要考虑的问题&quot;</span></span><br><span class="line">绝不要以明文存储密码</span><br><span class="line">永远使用 哈希算法 来处理密码，绝不要使用 Base64 或其他编码方式来存储密码，这和以明文存储密码是一样的，使用哈希，而不要使用编码。编码以及加密，都是双向的过程，而密码是保密的，应该只被它的所有者知道， 这个过程必须是单向的。哈希正是用于做这个的，从来没有解哈希这种说法， 但是编码就存在解码，加密就存在解密。</span><br><span class="line">绝不要使用弱哈希或已被破解的哈希算法，像 MD5 或 SHA1 ，只使用强密码哈希算法。</span><br><span class="line">绝不要以明文形式显示或发送密码，即使是对密码的所有者也应该这样。如果你需要 “忘记密码” 的功能，可以随机生成一个新的 一次性的（这点很重要）密码，然后把这个密码发送给用户。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="分布式架构下-session-共享方案"><a href="#分布式架构下-session-共享方案" class="headerlink" title="分布式架构下 session 共享方案"></a>分布式架构下 session 共享方案</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1. session 复制</span><br><span class="line">    任何一个服务器上的 session 发生改变（增删改），该节点会把这个 session 的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要 session ，以此来保证 session 同步</span><br><span class="line">    优点： 可容错，各个服务器间 session 能够实时响应。缺点： 会对网络负荷造成一定压力，如果 session 量大的话可能会造成网络堵塞，拖慢服务器性能。</span><br><span class="line"></span><br><span class="line">2. 粘性 session /IP 绑定策略</span><br><span class="line">    采用 Ngnix 中的 ip_hash 机制，将某个 ip的所有请求都定向到同一台服务器上，即将用户与服务器绑定。 用户第一次请求时，负载均衡器将用户的请求转发到了 A 服务器上，如果负载均衡器设置了粘性 session 的话，那么用户以后的每次请求都会转发到 A 服务器上，相当于把用户和 A 服务器粘到了一块，这就是粘性 session 机制。</span><br><span class="line">    优点： 简单，不需要对 session 做任何处理。缺点： 缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，他的 session 信息都将失效。适用场景： 发生故障对客户产生的影响较小；服务器发生故障是低概率事件 。实现方式： 以 Nginx 为例，在 upstream 模块配置 ip_hash 属性即可实现粘性 session。</span><br><span class="line"></span><br><span class="line">3. session 共享（常用）</span><br><span class="line">    使用分布式缓存方案比如 Memcached 、Redis 来缓存 session，但是要求 Memcached 或 Redis 必须是集群</span><br><span class="line">    把 session 放到 Redis 中存储，虽然架构上变得复杂，并且需要多访问一次 Redis ，但是这种方案带来的好处也是很大的：</span><br><span class="line">        实现了 session 共享；</span><br><span class="line">        可以水平扩展（增加 Redis 服务器）；</span><br><span class="line">        服务器重启 session 不丢失（不过也要注意 session 在 Redis 中的刷新/失效机制）；</span><br><span class="line">        不仅可以跨服务器 session 共享，甚至可以跨平台（例如网页端和 APP 端）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. session 持久化</span><br><span class="line">    将 session 存储到数据库中，保证 session 的持久化</span><br><span class="line">    优点： 服务器出现问题，session 不会丢失缺点： 如果网站的访问量很大，把 session 存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="只要关闭浏览器-，session-真的就消失了？"><a href="#只要关闭浏览器-，session-真的就消失了？" class="headerlink" title="只要关闭浏览器 ，session 真的就消失了？"></a>只要关闭浏览器 ，session 真的就消失了？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不对。对 session 来说，除非程序通知服务器删除一个 session，否则服务器会一直保留，程序一般都是在用户做 <span class="built_in">log</span> off 的时候发个指令去删除 session。然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 session id，而关闭浏览器后这个 session id 就消失了，再次连接服务器时也就无法找到原来的 session。如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 session id 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。恰恰是由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/22/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT/" data-id="cl29z23vx0000igvjb7jlg95b" data-title="Cookie、Session、Token、JWT" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/22/%E9%9D%A2%E8%AF%95/">面试题</a>
          </li>
        
          <li>
            <a href="/2022/04/22/http/">HTTP五大类面试题</a>
          </li>
        
          <li>
            <a href="/2022/04/22/css/css/">css 相关</a>
          </li>
        
          <li>
            <a href="/2022/04/22/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT/">Cookie、Session、Token、JWT</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>